[["index.html", "Analysing CRISPR Screens with edgeR Welcome", " Analysing CRISPR Screens with edgeR Göknur Giner 2023-10-15 Welcome Welcome to the “Analyzing CRISPR Screens with edgeR”. Our aim is to empower researchers like you with the tools and knowledge needed to navigate the complex landscape of CRISPR data analysis. This platform serves as the central hub for a comprehensive guide on leveraging one of the most commonly used differential expression analysis Bioconductor package edgeR, for the analysis of CRISPR screens. Whether you’re delving into CRISPR experiments for the first time or seeking advanced insights, this guide will equip you with essential skills and knowledge to extract meaningful information from your data using powerful and robust statistical methods presented in edgeR. Here we provide you with a robust foundation in the analysis of CRISPR data using edgeR. Throughout this guide, we walk you through various steps of typical CRISPR analysis workflows using example data set to count the single guide RNAs (sgRNAs) from your sequencing files (fastq, etc.), pre-process the count matrices (filtering, normalising, etc.), fit a statistical model to identify the hit guides, genes and pathways, and visualize the results. This guide is crafted with both novice and experienced researchers in mind. Whether you’re an experimental biologist stepping into the realm of CRISPR data or a seasoned bioinformatician seeking insights into edgeR in the context of CRISPR gene editing, you’ll find valuable content here. We make minimal assumptions about your previous programming or statistical experience, aiming to create a resource that is accessible to a broad audience. We welcome feedback from all users to improve this guide continually, enhancing accessibility and refining technical details. Your input is instrumental in making this resource more valuable to the community. "],["setting-up.html", "Setting up Install R Install RStudio Install required packages Load required packages Download the material Create necessary directories", " Setting up Install R R can be installed from the R-project website. Direct downloads for all platforms can be downloaded at the links below: Mac Windows Linux Install RStudio RStudio can be installed from the RStudio website. RStudio can be downloaded for all platforms at the link below: https://rstudio.com/products/rstudio/download/ Install required packages if (!require(&quot;BiocManager&quot;, quietly = TRUE)) install.packages(&quot;BiocManager&quot;) BiocManager::install(&quot;edgeR&quot;) BiocManager::install(&quot;GenomicAlignments&quot;) BiocManager::install(&quot;Rsubread&quot;) BiocManager::install(&quot;Biostrings&quot;) BiocManager::install(&quot;AnnotationDbi&quot;) BiocManager::install(&quot;org.Hs.eg.db&quot;) install.packages(&quot;ggplot2&quot;) install.packages(&quot;DT&quot;) install.packages(&quot;ggrepel&quot;) install.packages(&quot;RColorBrewer&quot;) BiocManager::install(&quot;GO.db&quot;) Load required packages library(edgeR) library(GenomicAlignments) library(Rsubread) library(Biostrings) library(AnnotationDbi) library(org.Hs.eg.db) library(ggplot2) library(DT) library(ggrepel) library(RColorBrewer) library(GO.db) Download the material The sequencing files and human GeCKO sgRNA library can be downloaded from the github repository by clicking on the following links. FASTQ files GeCKO human library Create necessary directories dir.create(&quot;./index&quot;) dir.create(&quot;./RData&quot;) dir.create(&quot;./tables&quot;) dir.create(&quot;./figures&quot;) "],["counting-the-sgrnas-with-rsubread.html", "Counting the sgRNAs with RSubread Build an index Align the FASTQ files Create a DGEList object", " Counting the sgRNAs with RSubread To count the sgRNAs, we must first load the human GeCKO sgRNA library, and subsequently, convert it into the FASTA format to construct an index for alignment. To do that we use DNAStringSet and writeXStringSet functions from GenomicAlignments Bioconductor package. GeCKO &lt;- read.delim(&quot;sgRNA_library/GeCKOv21_Human.tsv&quot;) GeCKO[1:2, ] gene_id UID seq 1 A1BG HGLibA_00001 GTCGCTGAGCTCCGATTCGA 2 A1BG HGLibA_00002 ACCTGTAGTTGCCGGCGTGC sgRNAs &lt;- DNAStringSet(GeCKO$seq) names(sgRNAs) &lt;- GeCKO$UID sgRNAs DNAStringSet object of length 122411: width seq names [1] 20 [48;5;159m[30mG[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m[48;5;223m[30mT[39m[49m[48;5;159m[30mG[39m[49m[48;5;217m[30mA[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;159m[30mG[39m[49m[48;5;217m[30mA[39m[49m[48;5;223m[30mT[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;159m[30mG[39m[49m[48;5;217m[30mA[39m[49m HGLibA_00001 [2] 20 [48;5;217m[30mA[39m[49m[48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;223m[30mT[39m[49m[48;5;159m[30mG[39m[49m[48;5;223m[30mT[39m[49m[48;5;217m[30mA[39m[49m[48;5;159m[30mG[39m[49m[48;5;223m[30mT[39m[49m[48;5;223m[30mT[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;159m[30mG[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m[48;5;159m[30mG[39m[49m[48;5;223m[30mT[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m HGLibA_00002 [3] 20 [48;5;157m[30mC[39m[49m[48;5;159m[30mG[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m[48;5;159m[30mG[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;223m[30mT[39m[49m[48;5;223m[30mT[39m[49m[48;5;159m[30mG[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m HGLibA_00003 [4] 20 [48;5;157m[30mC[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;157m[30mC[39m[49m[48;5;223m[30mT[39m[49m[48;5;159m[30mG[39m[49m[48;5;159m[30mG[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;157m[30mC[39m[49m HGLibA_00004 [5] 20 [48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;217m[30mA[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m[48;5;223m[30mT[39m[49m[48;5;217m[30mA[39m[49m[48;5;223m[30mT[39m[49m[48;5;217m[30mA[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;223m[30mT[39m[49m[48;5;159m[30mG[39m[49m[48;5;223m[30mT[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m HGLibA_00005 ... ... ... [122407] 20 [48;5;159m[30mG[39m[49m[48;5;159m[30mG[39m[49m[48;5;223m[30mT[39m[49m[48;5;159m[30mG[39m[49m[48;5;217m[30mA[39m[49m[48;5;223m[30mT[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;223m[30mT[39m[49m[48;5;217m[30mA[39m[49m[48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;159m[30mG[39m[49m[48;5;217m[30mA[39m[49m[48;5;223m[30mT[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m HGLibB_57024 [122408] 20 [48;5;159m[30mG[39m[49m[48;5;217m[30mA[39m[49m[48;5;159m[30mG[39m[49m[48;5;159m[30mG[39m[49m[48;5;159m[30mG[39m[49m[48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;217m[30mA[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;223m[30mT[39m[49m[48;5;159m[30mG[39m[49m[48;5;223m[30mT[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;223m[30mT[39m[49m HGLibB_57025 [122409] 20 [48;5;159m[30mG[39m[49m[48;5;223m[30mT[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;223m[30mT[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;217m[30mA[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;159m[30mG[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;217m[30mA[39m[49m[48;5;157m[30mC[39m[49m HGLibB_57026 [122410] 20 [48;5;157m[30mC[39m[49m[48;5;159m[30mG[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;159m[30mG[39m[49m[48;5;217m[30mA[39m[49m[48;5;159m[30mG[39m[49m[48;5;217m[30mA[39m[49m[48;5;223m[30mT[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;223m[30mT[39m[49m[48;5;217m[30mA[39m[49m[48;5;157m[30mC[39m[49m[48;5;223m[30mT[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m[48;5;223m[30mT[39m[49m[48;5;223m[30mT[39m[49m[48;5;157m[30mC[39m[49m HGLibB_57027 [122411] 20 [48;5;157m[30mC[39m[49m[48;5;223m[30mT[39m[49m[48;5;159m[30mG[39m[49m[48;5;217m[30mA[39m[49m[48;5;217m[30mA[39m[49m[48;5;217m[30mA[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;223m[30mT[39m[49m[48;5;223m[30mT[39m[49m[48;5;223m[30mT[39m[49m[48;5;217m[30mA[39m[49m[48;5;217m[30mA[39m[49m[48;5;157m[30mC[39m[49m[48;5;157m[30mC[39m[49m[48;5;217m[30mA[39m[49m[48;5;159m[30mG[39m[49m[48;5;223m[30mT[39m[49m[48;5;223m[30mT[39m[49m[48;5;159m[30mG[39m[49m HGLibB_57028 writeXStringSet(sgRNAs, file = &quot;./index/GeCKO.fa&quot;) Build an index Then we build an index of sgRNA library with buildindex function from RSubread package. buildindex(&quot;./index/GeCKO&quot;, &quot;./index/GeCKO.fa&quot;, indexSplit = FALSE) Align the FASTQ files Next step is to align the sequencing files with align function from RSubread and count the reads with readGAlignments function in GenomicAlignments. The subsequent phase involves aligning the sequencing files (FASTQ files) using the align function from RSubread and counting the reads for each sgRNA using the readGAlignments function in GenomicAlignments. fastqs &lt;- dir(path = &quot;./fastq_files&quot;, pattern = &quot;*.fastq.gz&quot;, full.names = TRUE) counts &lt;- list() mapping_results &lt;- list() for (i in 1:length(fastqs)) { mapping_results[[i]] &lt;- align(&quot;./index/GeCKO&quot;, fastqs[i], output_file = gsub(&quot;.fastq.gz&quot;, &quot;.bam&quot;, fastqs[i]), nthreads = 4, unique = TRUE, nBestLocations = 1, type = &quot;DNA&quot;, TH1 = 1, maxMismatches = 0, indels = 0) temp &lt;- readGAlignments(gsub(&quot;.fastq.gz&quot;, &quot;.bam&quot;, fastqs[i])) counts[[i]] &lt;- data.frame(table(seqnames(temp[width(temp) == &quot;20&quot;])), row.names = &quot;Var1&quot;) } my_counts &lt;- do.call(cbind, counts) colnames(my_counts) &lt;- c(&quot;Control_1&quot;, &quot;Control_2&quot;, &quot;ToxA_1&quot;, &quot;ToxA_2&quot;, &quot;ToxB_1&quot;, &quot;ToxB_2&quot;) write.table(my_counts, &quot;my_counts.txt&quot;) Create a DGEList object For downstream analysis, here we are going to convert count matrix obtained in the previous section into a DGEList object using the DGEList function from edgeR package. The DGEList object consists of three components: counts, information about samples and gene annotations. counts &lt;- read.table(&quot;my_counts.txt&quot;, header = TRUE) group &lt;- factor(c(&quot;Control&quot;, &quot;Control&quot;, &quot;ToxA&quot;, &quot;ToxA&quot;, &quot;ToxB&quot;, &quot;ToxB&quot;), levels = c(&quot;Control&quot;, &quot;ToxA&quot;, &quot;ToxB&quot;)) samples &lt;- data.frame(group = group, sampleName = colnames(counts), biorep = rep(c(1, 2), 3)) genes &lt;- GeCKO names(genes)[names(genes) == &quot;gene_id&quot;] &lt;- &quot;Symbol&quot; d &lt;- DGEList(counts = counts, samples = samples, genes = genes) d An object of class &quot;DGEList&quot; $counts Control_1 Control_2 ToxA_1 ToxA_2 ToxB_1 ToxB_2 HGLibA_00001 0 7 3 2 2 8 HGLibA_00002 0 0 0 0 0 0 HGLibA_00003 1 0 0 0 0 0 HGLibA_00004 9 0 0 0 0 1 HGLibA_00005 1 8 1 0 1 1 122406 more rows ... $samples group lib.size norm.factors sampleName biorep Control_1 Control 338214 1 Control_1 1 Control_2 Control 337711 1 Control_2 2 ToxA_1 ToxA 344188 1 ToxA_1 1 ToxA_2 ToxA 335848 1 ToxA_2 2 ToxB_1 ToxB 356569 1 ToxB_1 1 ToxB_2 ToxB 355131 1 ToxB_2 2 $genes Symbol UID seq HGLibA_00001 A1BG HGLibA_00001 GTCGCTGAGCTCCGATTCGA HGLibA_00002 A1BG HGLibA_00002 ACCTGTAGTTGCCGGCGTGC HGLibA_00003 A1BG HGLibA_00003 CGTCAGCGTCACATTGGCCA HGLibA_00004 A1CF HGLibA_00004 CGCGCACTGGTCCAGCGCAC HGLibA_00005 A1CF HGLibA_00005 CCAAGCTATATCCTGTGCGC 122406 more rows ... save(d, file = &quot;./RData/DGEList.RData&quot;) "],["preprocessing-the-data.html", "Preprocessing the data Check guide distribution Evaluate the uniformity Remove lowly expressed guides Look at density plots Normalise the counts Unsupervised clustering of samples Visualise guide abundance profiles of samples", " Preprocessing the data Before conducting the differential abundance analysis in a CRISPR screen, we eliminate guides that could compromise the statistical power in the downstream analysis. Specifically, we exclude non-targeting sgRNAs employed to assess the sgRNA library’s quality, as they are unnecessary for the further statistical analysis. Subsequently, we filter out guides with very low counts across many samples. The next step is normalization. The normalization following filtering is vital because each library is sequenced at varying depths, and libraries with higher counts will naturally yield higher counts. Normalization involves transforming raw counts onto a different scale where differences in library sizes are considered and adjusted for. load(&quot;./RData/DGEList.RData&quot;) Remove control guides First we remove 1000 control (non-targeting) sgRNAs from the count matrix as they are designed not to target in the genome. d.raw &lt;- d dim(d &lt;- d[!d$genes$Symbol %in% grep(&quot;Non&quot;, d$genes$Symbol, value = TRUE), ]) [1] 121411 6 Check guide distribution The control samples contain the majority of sgRNAs, and the numbers decrease in the treated samples. data &lt;- NULL sample_names &lt;- c(colnames(d), &quot;GeCKO&quot;) l &lt;- c(as.integer(colSums(!d$counts == 0)), nrow(d$counts)) t &lt;- c(as.character(d$samples$group), &quot;GeCKO&quot;) data &lt;- data.frame(row.name = sample_names, l = l, t = t) data &lt;- data[order(data$l, data$t), ] col &lt;- c(&quot;#FF6666&quot;, &quot;#6DAEB0&quot;, &quot;#FAA578&quot;, &quot;#FFB6C1&quot;) my_bar &lt;- barplot(data$l, xlim = c(0, 140000), names.arg = data$row.name, las = 1, space = 1, cex.names = 0.85, xlab = &quot;The number of detected guides&quot;, main = &quot;The distribution of guides&quot;, col = col[as.factor(data$t)], border = NA, legend = TRUE, horiz = TRUE) text(my_bar, x = data$l + 7000 # adjust this number , paste0(&quot;n:&quot;, data$l), las = 2) legend(&quot;bottomright&quot;, legend = levels(factor(data$t)), fill = col) Evaluate the uniformity The Gini index, originally an economic measure of inequality, is used in CRISPR analysis to evaluate the uniformity of sgRNA presence. A Gini index of 0 indicates evenness, while an index of 1 suggests unevenness. Here, it’s notable that the control samples exhibit greater uniformity compared to the treated samples. gini(d$counts) Control_1 Control_2 ToxA_1 ToxA_2 ToxB_1 ToxB_2 0.7743390 0.7519516 0.9493576 0.9198235 0.9703805 0.9723415 boxplot(gini(d$counts) ~ d$samples$sampleName, ylab = &quot;Gini Indices&quot;, xlab = &quot;&quot;, cex.axis = 0.8) Remove lowly expressed guides Guides lacking a substantial number of reads in any sample should be excluded from downstream analyses. There are multiple rationales for this choice. From a biological perspective, guides that fail to register at a biologically relevant level in any condition are deemed uninteresting and are consequently disregarded. From a statistical standpoint, the elimination of guides with low counts enhances the reliability of estimating the mean-variance relationship in the data. It also reduces the number of statistical tests required for subsequent analyses focused on differential abundance. To implement this, here we used two filtering methods: one permissive and the other strict. Strict filtering For the strict approach, guides with low expression were filtered out, retaining as many guides as possible with meaningful counts. This was achieved using the filterByExpr() function in the edgeR package, a tool commonly applied in RNA-seq experiments for automated gene filtering. Initially, the count matrix contained 122,411 guides. After applying filterByExpr(), 113,395 guides (93%) were removed due to their low presence, leaving 9,016 guides for further analysis. It’s worth noting that filterByExpr() often retains only one guide per gene, which is sub optimal for CRISPR screens, where the collective behavior of multiple guides targeting the same gene is essential for validation. keep.exprs &lt;- filterByExpr(d, group = d$samples$group) table(keep.exprs) keep.exprs FALSE TRUE 112601 8810 dim(d.filtered.s &lt;- d[keep.exprs, , keep.lib.sizes = FALSE]) [1] 8810 6 genes_sgrna &lt;- d.filtered.s$genes$Symbol length(unique(genes_sgrna)) [1] 7277 nsgrna &lt;- table(table(genes_sgrna)) nsgrna 1 2 3 4 5 6 5912 1215 135 13 1 1 barplot(nsgrna, col = &quot;#FF9999&quot;, ylim = c(0, 7000), border = NA, main = &quot;The distribution of number of sgRNAs per gene \\n (After strict filtering)&quot;) Permissive filtering To address the limitations of strict filtering, we used a more permissive filtering approach. This method involved defining guide-wise threshold (\\(th1\\)) and sample-wise threshold (\\(th2\\)). We utilize CPM (Counts Per Million) values instead of raw counts to prevent bias toward samples with larger library sizes. For this dataset, the median library size is about \\(341,201\\) and \\(th1\\) is computed as \\(1e6/341201 ≈ 0.29\\), so the permissive filtering keeps the guides that have a CPM of 0.29 or more in at least \\(th2=2\\) samples. This approach aims to strike a balance, allowing for the inclusion of as many guides as possible targeting the same gene, facilitating a more robust assessment of the collective impact of guides in CRISPR screens. Consequently, with the permissive approach, we retained \\(58171 (48\\%)\\) of the guides. th1 &lt;- as.vector(cpm(1, median(d$samples$lib.size))) th1 # median count per million reads (1e6/mean(d$samples$lib.size)) [1] 2.930824 th2 &lt;- 2 # average number of sample per condition keep.exprs &lt;- rowSums(cpm(d) &gt; th1) &gt;= th2 table(keep.exprs) keep.exprs FALSE TRUE 65484 55927 dim(d.filtered.p &lt;- d[keep.exprs, , keep.lib.sizes = FALSE]) [1] 55927 6 genes_sgrna &lt;- d.filtered.p$genes$Symbol length(unique(genes_sgrna)) [1] 19659 nsgrna &lt;- table(table(genes_sgrna)) nsgrna 1 2 3 4 5 6 2867 5150 5870 3983 1516 273 barplot(nsgrna, col = &quot;#FF9999&quot;, ylim = c(0, 7000), border = NA, main = &quot;The distribution of number of sgRNAs per gene \\n (After permissive filtering)&quot;) Look at density plots The density distributions of raw counts reveal the presence of numerous guides with low abundance, characterized by small log-cpm values. The application of permissive filtering appears to diminish the count of such lowly abundant guides. This reduction is evident in the decreased peakedness (kurtosis) of the distribution, accompanied by a shift towards greater symmetry as indicated by the balanced skewness. x &lt;- d nsamples &lt;- ncol(x) col.density &lt;- brewer.pal(nsamples, &quot;Paired&quot;) par(mfrow = c(1, 3)) samplenames &lt;- colnames(x) cpm &lt;- cpm(x) lcpm &lt;- cpm(x, log = TRUE) plot(density(lcpm[, 1], bw = 0.4), col = col.density[1], lwd = 2, ylim = c(0, 1), las = 2, main = &quot;&quot;, xlab = &quot;&quot;) title(main = &quot;A. Raw data&quot;, xlab = &quot;Log-cpm&quot;) for (i in 2:nsamples) { den &lt;- density(lcpm[, i], bw = 0.4) lines(den$x, den$y, col = col.density[i], lwd = 2) } legend(&quot;topright&quot;, samplenames, text.col = col.density, bty = &quot;n&quot;) x &lt;- d.filtered.p cpm &lt;- cpm(x) lcpm &lt;- cpm(x, log = TRUE) plot(density(lcpm[, 1], bw = 0.4), col = col.density[1], lwd = 2, ylim = c(0, 1), las = 2, main = &quot;&quot;, xlab = &quot;&quot;) title(main = &quot;B. Permissively filtered data&quot;, xlab = &quot;Log-cpm&quot;) for (i in 2:nsamples) { den &lt;- density(lcpm[, i], bw = 0.4) lines(den$x, den$y, col = col.density[i], lwd = 2) } legend(&quot;topright&quot;, samplenames, text.col = col.density, bty = &quot;n&quot;) x &lt;- d.filtered.s cpm &lt;- cpm(x) lcpm &lt;- cpm(x, log = TRUE) plot(density(lcpm[, 1], bw = 0.4), col = col.density[1], lwd = 2, ylim = c(0, 1), las = 2, main = &quot;&quot;, xlab = &quot;&quot;) title(main = &quot;C. Strictly filtered data&quot;, xlab = &quot;Log-cpm&quot;) for (i in 2:nsamples) { den &lt;- density(lcpm[, i]) lines(den$x, den$y, col = col.density[i], lwd = 2) } legend(&quot;topright&quot;, samplenames, text.col = col.density, bty = &quot;n&quot;) # dev.off() Normalise the counts During sample preparation or sequencing, factors unrelated to biological processes can influence the expression of individual samples. The expectation is that all samples should exhibit a comparable range and distribution of expression values. To ensure uniformity across the entire experiment, normalization becomes necessary. Commonly, raw counts are transformed into a scale that accounts for differences in library sizes. In our case, we first employed the cpm function in edgeR to transform raw counts into counts per million (CPM) and log2-counts per million (log-CPM) values. This transformation facilitates a standardized representation of expression values, enabling more meaningful comparisons across samples. CPM normalised counts par(mfrow = c(1, 3)) yy &lt;- d[, order(d$samples$group, colSums(d$counts))] yy.logcpm &lt;- cpm(yy, log = T) boxplot(yy.logcpm, las = 2, pch = 19, col = col[as.factor(yy$samples$group)], outcex = 0.3, outcol = col[as.factor(yy$samples$group)], labels = colnames(yy.logcpm), main = &quot;A. CPM normalised raw data&quot;, ylab = &quot;SgRNA representation (log2 cpm normalised reads)&quot;) legend(&quot;topleft&quot;, legend = levels(factor(yy$samples$group)), col = col, pch = 19, cex = 0.5) yy &lt;- d.filtered.p[, order(d.filtered.p$samples$group, colSums(d.filtered.p$counts))] yy.logcpm &lt;- cpm(yy, log = T) boxplot(yy.logcpm, las = 2, pch = 19, col = col[as.factor(yy$samples$group)], outcex = 0.3, outcol = col[as.factor(yy$samples$group)], labels = colnames(yy.logcpm), main = &quot;B. CPM normalised permissively filtered data&quot;, ylab = &quot;SgRNA representation (log2 cpm normalised reads)&quot;) legend(&quot;topleft&quot;, legend = levels(factor(yy$samples$group)), col = col, pch = 19, cex = 0.5) yy &lt;- d.filtered.s[, order(d.filtered.s$samples$group, colSums(d.filtered.s$counts))] yy.logcpm &lt;- cpm(yy, log = T) boxplot(yy.logcpm, las = 2, pch = 19, col = col[as.factor(yy$samples$group)], outcex = 0.3, outcol = col[as.factor(yy$samples$group)], labels = colnames(yy.logcpm), main = &quot;C. CPM normalised strictly filtered data&quot;, ylab = &quot;SgRNA representation (log2 cpm normalised reads)&quot;) legend(&quot;topleft&quot;, legend = levels(factor(yy$samples$group)), col = col, pch = 19, cex = 0.5) Following that, we implemented the TMM normalization using the normLibSizes function within the edgeR package. When dealing with DGEList objects, the normalization factors are automatically stored in the DGEList object. In the permissively filtered data, the influence of TMM normalization is modest, as suggested by the scaling factors, all of which are reasonably close to 1. However, notable is the fact that the normalization factors for ToxB samples are below one. This implies that a small number of highly abundant guide counts disproportionately influence the sequencing, causing counts for other genes to be lower than expected based on the library size. Consequently, the library size will be reduced, akin to scaling up the counts within that library. Such a scenario is typical in CRISPR screens. To address this, introducing a prior value to the counts—sufficiently small to avoid altering the overall data distribution—serves to balance the library sizes, mitigating the impact of a few highly expressed guides. TMM normalised counts par(mfrow = c(2, 2)) yy &lt;- d.filtered.p[, order(d.filtered.p$samples$group, colSums(d.filtered.p$counts))] yy$samples$norm.factors &lt;- normLibSizes(yy$counts, method = &quot;TMM&quot;) yy$samples[, 1:3] # TMM normalization factors of permissively filtered data group lib.size norm.factors Control_2 Control 258228 1.3182523 Control_1 Control 261610 1.3544882 ToxA_2 ToxA 323563 1.1733655 ToxA_1 ToxA 334876 1.2013967 ToxB_2 ToxB 344894 0.5817462 ToxB_1 ToxB 346781 0.6829248 yy.logcpm &lt;- cpm(yy, log = T) boxplot(yy.logcpm, las = 2, pch = 19, col = col[as.factor(yy$samples$group)], outcex = 0.3, outcol = col[as.factor(yy$samples$group)], labels = colnames(yy.logcpm), main = &quot;A. TMM normalised permissively filtered data&quot;, ylab = &quot;SgRNA representation (log2 cpm normalised reads)&quot;) legend(&quot;topleft&quot;, legend = levels(factor(yy$samples$group)), col = col, pch = 19, cex = 0.5) yy &lt;- d.filtered.p[, order(d.filtered.p$samples$group, colSums(d.filtered.p$counts))] yy$samples$norm.factors &lt;- normLibSizes(yy$counts + 100, method = &quot;TMM&quot;) yy$samples[, 1:3] # TMM normalization factors of permissively filtered data after adding a prior count of 100 group lib.size norm.factors Control_2 Control 258228 1.0193334 Control_1 Control 261610 1.0187857 ToxA_2 ToxA 323563 0.9939975 ToxA_1 ToxA 334876 0.9917365 ToxB_2 ToxB 344894 0.9884410 ToxB_1 ToxB 346781 0.9882539 yy.logcpm &lt;- cpm(yy, log = T) boxplot(yy.logcpm, las = 2, pch = 19, col = col[as.factor(yy$samples$group)], outcex = 0.3, outcol = col[as.factor(yy$samples$group)], labels = colnames(yy.logcpm), main = &quot;B. TMM offset-normalised permissively filtered data&quot;, ylab = &quot;SgRNA representation (log2 cpm normalised reads)&quot;) legend(&quot;topleft&quot;, legend = levels(factor(yy$samples$group)), col = col, pch = 19, cex = 0.5) yy.norm &lt;- yy # we continue downstream analysis with this object yy &lt;- d.filtered.s[, order(d.filtered.s$samples$group, colSums(d.filtered.s$counts))] yy$samples$norm.factors &lt;- normLibSizes(yy$counts, method = &quot;TMM&quot;) yy$samples[, 1:3] # TMM normalization factors of strictly filtered data group lib.size norm.factors Control_1 Control 56390 2.0995847 Control_2 Control 57402 1.8983192 ToxA_2 ToxA 242030 1.9418813 ToxA_1 ToxA 283958 1.8621100 ToxB_1 ToxB 298310 0.2919254 ToxB_2 ToxB 300952 0.2376826 yy.logcpm &lt;- cpm(yy, log = T) boxplot(yy.logcpm, las = 2, pch = 19, col = col[as.factor(yy$samples$group)], outcex = 0.3, outcol = col[as.factor(yy$samples$group)], labels = colnames(yy.logcpm), main = &quot;C. TMM normalised strictly filtered data&quot;, ylab = &quot;SgRNA representation (log2 cpm normalised reads)&quot;) legend(&quot;topleft&quot;, legend = levels(factor(yy$samples$group)), col = col, pch = 19, cex = 0.5) yy &lt;- d.filtered.s[, order(d.filtered.s$samples$group, colSums(d.filtered.s$counts))] yy$samples$norm.factors &lt;- normLibSizes(yy$counts + 100, method = &quot;TMM&quot;) yy$samples[, 1:3] # TMM normalization factors of strictly filtered data after adding a prior count of 100 group lib.size norm.factors Control_1 Control 56390 1.1054064 Control_2 Control 57402 1.1063956 ToxA_2 ToxA 242030 1.0496637 ToxA_1 ToxA 283958 1.0223192 ToxB_1 ToxB 298310 0.8749980 ToxB_2 ToxB 300952 0.8708108 yy.logcpm &lt;- cpm(yy, log = T) boxplot(yy.logcpm, las = 2, pch = 19, col = col[as.factor(yy$samples$group)], outcex = 0.3, outcol = col[as.factor(yy$samples$group)], labels = colnames(yy.logcpm), main = &quot;D. TMM offset-normalised strictly filtered data&quot;, ylab = &quot;SgRNA representation (log2 cpm normalised reads)&quot;) legend(&quot;topleft&quot;, legend = levels(factor(yy$samples$group)), col = col, pch = 19, cex = 0.5) dev.off() RStudioGD 2 Unsupervised clustering of samples A Multi-dimensional Scaling (MDS) plot visually depicts the similarities and differences among samples in an unsupervised manner, providing a preliminary understanding of the potential for identifying differential abundance before formal testing. The leading fold-change is conventionally defined as the root-mean-square of the largest 500 log2-fold changes between sample pairs. For this purpose, we utilize the plotMDS function from the limma package. It’s worth noting that loading the limma package is redundant, as edgeR already includes and invokes its functions. lcpm &lt;- cpm(yy.norm, log = TRUE) cols &lt;- col plotMDS(lcpm, col = cols[factor(yy.norm$samples$group)], main = &quot;MDS plot of permissevly filtered and TMM offset-normalised data&quot;, pch = 16, cex = 2) legend(&quot;bottomright&quot;, legend = levels(factor(yy.norm$samples$group)), col = cols, pch = 16, cex = 0.8) We can see that the biological replicates of control and treated samples cluster well within the groups over dimension 1 and 2. The first dimension accounts for largest variability in the data. Then the larger the dimension, the lower the variation is. While samples exhibit grouping tendencies, there are significant abundance distinctions between control and treated samples. Consequently, we anticipate that when performing pairwise comparisons among control and treated samples, there will be a higher count of differentially abundant guides in comparisons. Visualise guide abundance profiles of samples A more detailed exploration of the normalization procedure applied to individual samples can be accomplished using mean-difference (MD) plots. In an MD plot, the library size-adjusted log-fold change between two libraries (the difference) is graphed against the average log-expression across those libraries (the mean). It is a good practice to look at MD plots for all samples for a quality check. We use plotMD from edgeR package to do that. par(mfrow = c(3, 2)) for (i in 1:6) { plotMD(yy, column = i) abline(h = 0, col = &quot;red&quot;, lty = 2, lwd = 2) } dev.off() RStudioGD 2 If the bulk of the counts are centered around the line of zero log-fold change. The diagonal lines in the lower left of the plot correspond to genes with counts of 0, 1, 2 and so on in the first sample. For a good quality, we expect he majority of the counts to be concentrated near the zero log-fold change line. However, this is hardly ever the case for CRISPR experiments due to the sparse nature of CRISPR screen counts. The diagonal lines in the lower-left portion of the plot correspond to guides with counts of very low numbers. And it is typical for treated samples to observe a positive skew, with a number of very highly upregulated guides in the upper right of the plots. These points correspond to the guides that are both highly abundant and highly up-regulated in the given sample compared to others. Especially ToxB samples are more positively skewed than ToxA samples. These guides also explain why the normalization factor for ToxB samples were well below one before adding an offset. By contrast, the log-ratios for control samples were somewhat negatively skewed, corresponding to their normalization factor above one. Although we used TMM normalization with an added offset to the counts, a more specialized normalization methods are needed for accurate CRISPR screen analyses. "],["differential-abundance-analysis-at-guide-level.html", "Differential abundance analysis at guide level Create the design matrix Fit a model when there is no biological replicates Fit a model when there are biological replicates", " Differential abundance analysis at guide level Differential abundance analysis in the context of CRISPR typically refers to the identification of significant differences in the abundance of sgRNAs between different experimental conditions or sample groups. Empirical analysis of Digital Gene Expression edgeR is one of the most widely used Bioconductor packages designed for the analysis of differential gene expression in RNA-seq data. Here, we harness the robust capabilities of edgeR for differential expression analysis to precisely identify those sgRNAs that have a significant impact on the phenotype under investigation. edgeR offers two distinct pipelines: the classic edgeR and the glm (generalized linear model) edgeR. 1. Classic edgeR: This pipelin is based on exactTest function and it can be used when there is no biological replicates in any condition. 2. edgeR glm (Generalized Linear Model): This pipeline splits into two distinct approaches with stricter error rate than classic edgeR: a. edgeR glmLRT (Generalized Linear Model Likelihood Ratio Test): This approach relies on negative binomial generalized linear models, and the test employed is the Likelihood Ratio Test. This method ensures a more stringent control over the error rate compared to classic edgeR. b. edgeR quasi glmQLFTest (Generalized Linear Model Quasi-Likelihood F-test): In this statistical methodology, negative binomial generalized linear models are employed, featuring F-tests instead of likelihood ratio tests. This pipeline is also controls the error rate better than classic edgeR, additionally edgeR-quasi excels in low-count situations. Create the design matrix For further statistical modeling using edgeR, we now need to define a design matrix containing the factors in the experiment. design &lt;- model.matrix(~group, data = yy.norm$samples) design (Intercept) groupToxA groupToxB Control_2 1 0 0 Control_1 1 0 0 ToxA_2 1 1 0 ToxA_1 1 1 0 ToxB_2 1 0 1 ToxB_1 1 0 1 attr(,&quot;assign&quot;) [1] 0 1 1 attr(,&quot;contrasts&quot;) attr(,&quot;contrasts&quot;)$group [1] &quot;contr.treatment&quot; Fit a model when there is no biological replicates While it’s generally advisable to include biological replicates in experimental designs for statistical rigor and robust conclusions, there may be situations in CRISPR screens where researchers choose not to include them initially, especially in exploratory phases. The decision often involves a trade-off between the depth of analysis and the available resources. However, as the study progresses and findings are prioritized, additional experiments with biological replicates are often conducted to validate and strengthen the results. In instances where biological replicates are unavailable, they are not ideal but classic edgeR provides two alternative solutions: one involves the exactTest, and the other employs the Generalized Linear Model Likelihood Ratio Test (glmLRT). In such scenarios, a crucial step is to determine a sensible estimate for common Biological Coefficient of Variation (BCV). However, the p-values will heavily depend on the initial BCV estimate. This BCV estimate is utilized and the statistical model is conducted as follows: Classic edgeR Here we subset only one biological replicate of each condition. bcv &lt;- 0.6 yy.norm.no_biorep &lt;- DGEList(counts = yy.norm$counts[, c(2, 4, 6)], samples = yy.norm$samples[c(2, 4, 6), ], genes = yy.norm$genes) et.toxb &lt;- exactTest(yy.norm.no_biorep, dispersion = bcv^2, pair = c(1, 3)) et.toxa &lt;- exactTest(yy.norm.no_biorep, dispersion = bcv^2, pair = c(1, 2)) head(topTags(et.toxb, n = Inf)) Comparison of groups: ToxB-Control Symbol UID seq logFC logCPM HGLibA_56745 ZNF784 HGLibA_56745 GCAAGCTGTAGTGCGCGCGC 16.40706 13.54169 HGLibA_62457 hsa-mir-590 HGLibA_62457 TTATTCATAAAAGTGCAGTA 15.52052 12.65606 HGLibA_04839 BRPF1 HGLibA_04839 TACTGCTGTGGCCCACGCCG 14.37376 11.51312 HGLibA_39135 PSMC3IP HGLibA_39135 AATCGTGGCCCTCACTGCTA 14.36467 11.51097 HGLibA_39953 RAB44 HGLibA_39953 CAAGATGACCAGCCGCCTGC 14.35794 11.49787 HGLibB_51676 TRPC5 HGLibB_51676 CTCCCGACTGAACATCTATA 11.58312 12.08571 PValue FDR HGLibA_56745 4.396582e-10 2.458876e-05 HGLibA_62457 2.421539e-09 6.771472e-05 HGLibA_04839 2.197430e-08 2.349355e-04 HGLibA_39135 2.237347e-08 2.349355e-04 HGLibA_39953 2.266119e-08 2.349355e-04 HGLibB_51676 2.749944e-08 2.349355e-04 par(mfrow = c(1, 2)) plotMD(et.toxb) plotMD(et.toxa) dev.off() RStudioGD 2 write.csv(et.toxa, file = paste0(&quot;./tables/&quot;, Sys.Date(), &quot;Classic_edgeR-ToxAvsCtrl-DE-sgRNAs.csv&quot;)) write.csv(et.toxb, file = paste0(&quot;./tables/&quot;, Sys.Date(), &quot;Classic_edgeR-ToxBvsCtrl-DE-sgRNAs.csv&quot;)) edgeR glmLRT par(mfrow = c(1, 2)) fit &lt;- glmFit(yy.norm.no_biorep, dispersion = bcv^2) lrt.toxa &lt;- glmLRT(fit, coef = &quot;y$samples$groupToxA&quot;) lrt.toxb &lt;- glmLRT(fit, coef = &quot;y$samples$groupToxB&quot;) topTags(lrt.toxa) Coefficient: y$samples$groupToxA Symbol UID seq logFC logCPM HGLibB_38324 PRDM13 HGLibB_38324 GCAAGTACCTGTCAGACCGC 13.79029 10.887298 HGLibB_04039 B4GALT7 HGLibB_04039 GCGAGGACGACGAGTTCTAC 13.55125 10.649647 HGLibA_20923 HBEGF HGLibA_20923 GCCCTCTCCGAAGCCGCTCC 13.38190 10.640050 HGLibB_44908 SLC35B2 HGLibB_44908 TCCGCCTGAAGTACTGCACC 10.90573 11.410148 HGLibB_42762 SBSPON HGLibB_42762 GACAAGCTACGTCTCCACAC 12.68573 9.912502 HGLibB_20894 HBEGF HGLibB_20894 TCTTGAACTAGCTGCCACCC 10.36379 11.041123 HGLibB_23505 IQGAP3 HGLibB_23505 CACTCACAGGCTGCCCAGCC 12.37695 9.517303 HGLibA_07161 CAPN15 HGLibA_07161 CATGTCGTCCACCAGCACCG 12.08184 9.336969 HGLibA_56457 ZNF649 HGLibA_56457 ACTTAAGCTGTGACTTGCTG 11.97552 9.198546 HGLibA_55349 ZKSCAN2 HGLibA_55349 ACCAGTGAAAGATGTCCACG 11.95656 9.262887 LR PValue FDR HGLibB_38324 32.72439 1.061960e-08 0.0004436210 HGLibB_04039 31.80684 1.702923e-08 0.0004436210 HGLibA_20923 31.15712 2.379643e-08 0.0004436210 HGLibB_44908 30.37388 3.562930e-08 0.0004981600 HGLibB_42762 28.48975 9.419562e-08 0.0009711574 HGLibB_20894 28.29456 1.041884e-07 0.0009711574 HGLibB_23505 27.30909 1.733939e-07 0.0013853431 HGLibA_07161 26.18251 3.106240e-07 0.0020335084 HGLibA_56457 25.77718 3.831925e-07 0.0020335084 HGLibA_55349 25.70492 3.978110e-07 0.0020335084 topTags(lrt.toxb) Coefficient: y$samples$groupToxB Symbol UID seq logFC logCPM HGLibA_56745 ZNF784 HGLibA_56745 GCAAGCTGTAGTGCGCGCGC 16.45477 13.54169 HGLibA_62457 hsa-mir-590 HGLibA_62457 TTATTCATAAAAGTGCAGTA 15.56822 12.65606 HGLibA_04839 BRPF1 HGLibA_04839 TACTGCTGTGGCCCACGCCG 14.42146 11.51312 HGLibA_39135 PSMC3IP HGLibA_39135 AATCGTGGCCCTCACTGCTA 14.41237 11.51097 HGLibA_39953 RAB44 HGLibA_39953 CAAGATGACCAGCCGCCTGC 14.40564 11.49787 HGLibB_00899 ADCK5 HGLibB_00899 CCTCGGAGCCCGCTATGTCA 14.27026 11.37898 HGLibA_03500 ATG5 HGLibA_03500 TTCCATGAGTTTCCGATTGA 14.19247 11.28652 HGLibA_25094 KLHDC10 HGLibA_25094 GTTTAAGGAATATGCTGTCC 14.13953 11.24048 HGLibB_43525 SERPINE1 HGLibB_43525 TCCACTGGCCGTTGAAGTAG 14.02994 11.12450 HGLibB_51676 TRPC5 HGLibB_51676 CTCCCGACTGAACATCTATA 11.58768 12.08571 LR PValue FDR HGLibA_56745 42.97099 5.555765e-11 3.107173e-06 HGLibA_62457 39.55929 3.182494e-10 8.899368e-06 HGLibA_04839 35.14919 3.053877e-09 3.524250e-05 HGLibA_39135 35.11426 3.109157e-09 3.524250e-05 HGLibA_39953 35.08838 3.150759e-09 3.524250e-05 HGLibB_00899 34.56813 4.115905e-09 3.724658e-05 HGLibA_03500 34.26922 4.799120e-09 3.724658e-05 HGLibA_25094 34.06582 5.327885e-09 3.724658e-05 HGLibB_43525 33.64485 6.614986e-09 4.110626e-05 HGLibB_51676 32.99376 9.245512e-09 5.170737e-05 plotMD(lrt.toxa, main = &quot;ToxA vs Control&quot;) abline(h = c(-3, 3), col = &quot;blue&quot;) plotMD(lrt.toxb, main = &quot;ToxB vs Control&quot;) abline(h = c(-3, 3), col = &quot;blue&quot;) dev.off() RStudioGD 2 lrt.toxa$table$Symbol &lt;- lrt.toxa$genes$Symbol lrt.toxb$table$Symbol &lt;- lrt.toxb$genes$Symbol write.csv(lrt.toxa$table, file = paste0(&quot;./tables/&quot;, Sys.Date(), &quot;edgeR_glmLRT-ToxAvsCtrl-DE-sgRNAs.csv&quot;)) write.csv(lrt.toxb$table, file = paste0(&quot;./tables/&quot;, Sys.Date(), &quot;edgeR_glmLRT-ToxBvsCtrl-DE-sgRNAs.csv&quot;)) datatable(format(lrt.toxa$table[order(lrt.toxb$table$PValue, decreasing = FALSE), ], format = &quot;e&quot;, digits = 3)) datatable(format(lrt.toxb$table[order(lrt.toxb$table$PValue, decreasing = FALSE), ], format = &quot;e&quot;, digits = 3)) Fit a model when there are biological replicates When there are a minimum of two biological replicates for each condition under consideration, the edgeR glm method performs better than classic edgeR in CRISPR experiments. To employ edgeR glm, it’s essential to estimate the dispersion parameter of the negative binomial (NB) distribution. This parameter is crucial as it accommodates the variability observed between biological replicates. Dispersion estimates and biological variation These estimates can be visualized with plotBCV function from edgeR. yy.norm &lt;- estimateDisp(yy.norm, design) yy.norm$common.dispersion [1] 0.6331858 bcv &lt;- sqrt(yy.norm$common.dispersion) bcv [1] 0.7957297 plotBCV(yy.norm) BCV is computed as the square root of common dispersion, which is 0.8 (larger than 0.3) in this experiment. This is high considering that genetically identical cells are used to deign the experiment. The trended dispersion shows that when the abundance gets higher, the variation decreases. At low logCPM, the dispersion is very large. edgeR glmLRT fit &lt;- glmFit(yy.norm, design) lrt &lt;- glmLRT(fit, coef = &quot;groupToxA&quot;) lrt2.toxa &lt;- topTags(lrt, n = Inf, sort.by = &quot;PValue&quot;)$table lrt &lt;- glmLRT(fit, coef = &quot;groupToxB&quot;) lrt2.toxb &lt;- topTags(lrt, n = Inf, sort.by = &quot;PValue&quot;)$table datatable(format(lrt2.toxa[order(lrt2.toxa$FDR, decreasing = FALSE), ], format = &quot;e&quot;, digits = 3)) write.csv(lrt2.toxa, file = paste0(&quot;./tables/&quot;, Sys.Date(), &quot;-edgeR_glmLRT-with_biorep-ToxAvsCtrl-DE-sgRNAs.csv&quot;)) write.csv(lrt2.toxb, file = paste0(&quot;./tables/&quot;, Sys.Date(), &quot;-edgeR_glmLRT-with_biorep-ToxBvsCtrl-DE-sgRNAs.csv&quot;)) edgeR quasi Both edgeR glm and edgeR quasi are viable options. So next we will continue analyzing the given example using edgeR quasi. It’s important to note that, under the quasi-likelihood (QL) pipeline, only the trended dispersion is utilized, not The tagwise and common estimates. The QL dispersions can be estimated by utilizing the glmQLFit function and subsequently visualized using the plotQLDisp function. Also note that the results of this pipeline can be quite conservative and as shown below, there mey be only a few or no significant hit can be detected. Both edgeR glm and edgeR quasi are feasible choices. Therefore, we will proceed with the analysis of the provided example using edgeR quasi. It’s crucial to highlight that, within the quasi-likelihood (QL) pipeline, only the trended dispersion is employed, not the tagwise and common estimates. The QL dispersions can be estimated using the glmQLFit function and visualized through the plotQLDisp function. A graphical representation with plotQLDisp below depicts the quarter-root QL dispersion plotted against the average abundance of each gene. The estimates are presented for the raw dispersions (pre-empirical Bayes moderation), trended dispersions, and squeezed dispersions (post-empirical Bayes moderation). Additionally, it’s worth noting that the outcomes of this pipeline can be conservative, as demonstrated below, where only a few or no significant hits may be detected. fit &lt;- glmQLFit(yy.norm, design, robust = TRUE) plotQLDisp(fit) qlf.toxa &lt;- glmQLFTest(fit, coef = &quot;groupToxA&quot;) qlf2.toxa &lt;- topTags(qlf.toxa, n = Inf, sort.by = &quot;PValue&quot;)$table datatable(format(qlf2.toxa[order(qlf2.toxa$FDR, decreasing = FALSE), ], format = &quot;e&quot;, digits = 3)) write.csv(qlf.toxa, file = paste0(&quot;./tables/&quot;, Sys.Date(), &quot;-edgeR_glmQLF-with_biorep-ToxAvsCtrl-DE-sgRNAs.csv&quot;)) qlf.toxb &lt;- glmQLFTest(fit, coef = &quot;groupToxB&quot;) qlf2.toxb &lt;- topTags(qlf.toxb, n = Inf, sort.by = &quot;PValue&quot;)$table datatable(format(qlf2.toxb[order(qlf2.toxb$FDR, decreasing = FALSE), ], format = &quot;e&quot;, digits = 3)) write.csv(qlf.toxb, file = paste0(&quot;./tables/&quot;, Sys.Date(), &quot;-edgeR_glmQLF-with_biorep-ToxBvsCtrl-DE-sgRNAs.csv&quot;)) "],["visualise-hit-guides.html", "Visualise hit guides Volcano plot (ToxA vs Control) Volcano plot (ToxB vs Control)", " Visualise hit guides A volcano plot is a scatter plot that visualizes the differential abundance of guides. The fold change is typically displayed on the x-axis, while the y-axis represents the corresponding p-values. The significantly differentially abundant genes are the ones found in the upper-left and upper-right corners. Below we visualise the hits for ToxA vs Control and ToxB vs Control samples, respectively. Volcano plot (ToxA vs Control) # remove rows that contain NA values de &lt;- lrt2.toxa[complete.cases(lrt2.toxa), ] colnames(de)[colnames(de) == &quot;logFC&quot;] &lt;- &quot;log2FoldChange&quot; colnames(de)[colnames(de) == &quot;PValue&quot;] &lt;- &quot;pvalue&quot; colnames(de)[colnames(de) == &quot;Symbol&quot;] &lt;- &quot;gene_symbol&quot; colnames(de)[colnames(de) == &quot;FDR&quot;] &lt;- &quot;adjusted_pvalue&quot; de$diffabundant &lt;- &quot;Pass p-value cuttoff&quot; de$diffabundant[de$adjusted_pvalue &gt; 0.05] &lt;- &quot;Not Significant&quot; de$diffabundant[de$log2FoldChange &lt; -5 &amp; de$log2FoldChange &gt;= 5 &amp; de$adjusted_pvalue &lt; 0.05] &lt;- &quot;Pass p-value &amp; Log2FC cuttoff&quot; de$diffabundant[de$log2FoldChange &gt;= 5 &amp; de$adjusted_pvalue &lt;= 0.05] &lt;- &quot;Up&quot; de$diffabundant[de$log2FoldChange &lt; -5 &amp; de$adjusted_pvalue &lt;= 0.05] &lt;- &quot;Down&quot; head(de) gene_symbol UID seq log2FoldChange HGLibB_38324 PRDM13 HGLibB_38324 GCAAGTACCTGTCAGACCGC 11.209176 HGLibA_32966 NUDT2 HGLibA_32966 ATGAGCACCAAGCCTACCGC 11.594388 HGLibB_42762 SBSPON HGLibB_42762 GACAAGCTACGTCTCCACAC 12.255728 HGLibB_44908 SLC35B2 HGLibB_44908 TCCGCCTGAAGTACTGCACC 10.286574 HGLibB_45454 SLIT2 HGLibB_45454 TCTCTAGTTCTTTAAGATCC 11.404868 HGLibB_23505 IQGAP3 HGLibB_23505 CACTCACAGGCTGCCCAGCC 9.781491 logCPM LR pvalue adjusted_pvalue diffabundant HGLibB_38324 10.829302 89.05910 3.831913e-21 2.143074e-16 Up HGLibA_32966 8.780164 73.01061 1.289546e-17 3.195504e-13 Up HGLibB_42762 9.530267 72.44893 1.714112e-17 3.195504e-13 Up HGLibB_44908 11.311403 69.70313 6.893661e-17 9.638544e-13 Up HGLibB_45454 8.763229 68.20288 1.475103e-16 1.649962e-12 Up HGLibB_23505 9.434533 66.97834 2.745064e-16 2.491273e-12 Up g_down &lt;- which(de$log2FoldChange &gt; 5 &amp; de$adjusted_pvalue &lt;= 0.05) g_up &lt;- which(de$log2FoldChange &lt; -5 &amp; de$adjusted_pvalue &lt;= 0.05) de$delabel &lt;- NA de$delabel[c(g_down[1:20], g_up[1:20])] &lt;- de$gene_symbol[c(g_down[1:20], g_up[1:20])] ggplot(data = de, aes(x = log2FoldChange, y = -log10(adjusted_pvalue), col = diffabundant, label = delabel)) + geom_point() + theme_minimal() + geom_text_repel(max.overlaps = Inf) + scale_color_manual(values = c(&quot;blue&quot;, &quot;black&quot;, &quot;gray&quot;, &quot;red&quot;)) + geom_vline(xintercept = c(-5, 5), col = &quot;darkred&quot;) + geom_hline(yintercept = -log10(0.05), col = &quot;darkred&quot;) Volcano plot (ToxB vs Control) # remove rows that contain NA values de &lt;- lrt2.toxb[complete.cases(lrt2.toxb), ] colnames(de)[colnames(de) == &quot;logFC&quot;] &lt;- &quot;log2FoldChange&quot; colnames(de)[colnames(de) == &quot;PValue&quot;] &lt;- &quot;pvalue&quot; colnames(de)[colnames(de) == &quot;Symbol&quot;] &lt;- &quot;gene_symbol&quot; colnames(de)[colnames(de) == &quot;FDR&quot;] &lt;- &quot;adjusted_pvalue&quot; de$diffabundant &lt;- &quot;Pass p-value cuttoff&quot; de$diffabundant[de$adjusted_pvalue &gt; 0.05] &lt;- &quot;Not Significant&quot; de$diffabundant[de$log2FoldChange &lt; -5 &amp; de$log2FoldChange &gt;= 5 &amp; de$adjusted_pvalue &lt; 0.05] &lt;- &quot;Pass p-value &amp; Log2FC cuttoff&quot; de$diffabundant[de$log2FoldChange &gt;= 5 &amp; de$adjusted_pvalue &lt;= 0.05] &lt;- &quot;Up&quot; de$diffabundant[de$log2FoldChange &lt; -5 &amp; de$adjusted_pvalue &lt;= 0.05] &lt;- &quot;Down&quot; head(de) gene_symbol UID seq log2FoldChange HGLibA_02011 ANKRD16 HGLibA_02011 CGACGTCGATGTGCCCACAC 10.154406 HGLibA_27301 LRRC29 HGLibA_27301 CTGTGTCCAGTCCCGCTTCG 7.300759 HGLibB_00250 ABHD14B HGLibB_00250 TTAAGTACCTGGCAGGTCAA 7.407535 HGLibA_42214 RPUSD4 HGLibA_42214 GACCCGAGGAATTCTCCACC 10.519154 HGLibA_39135 PSMC3IP HGLibA_39135 AATCGTGGCCCTCACTGCTA 9.567023 HGLibB_42757 SBNO2 HGLibB_42757 AGGGTATGGCGGCAGCGAGA 9.895113 logCPM LR pvalue adjusted_pvalue diffabundant HGLibA_02011 11.875792 94.27706 2.743108e-22 1.534138e-17 Up HGLibA_27301 11.784015 81.55213 1.706991e-19 4.773343e-15 Up HGLibB_00250 12.149716 78.52597 7.895333e-19 1.471874e-14 Up HGLibA_42214 10.140291 75.48743 3.677413e-18 5.141667e-14 Up HGLibA_39135 11.552013 68.32588 1.385901e-16 1.550186e-12 Up HGLibB_42757 9.521769 67.73967 1.865714e-16 1.739064e-12 Up g_down &lt;- which(de$log2FoldChange &gt; 5 &amp; de$adjusted_pvalue &lt;= 0.05) g_up &lt;- which(de$log2FoldChange &lt; -5 &amp; de$adjusted_pvalue &lt;= 0.05) de$delabel &lt;- NA de$delabel[c(g_down[1:20], g_up[1:20])] &lt;- de$gene_symbol[c(g_down[1:20], g_up[1:20])] ggplot(data = de, aes(x = log2FoldChange, y = -log10(adjusted_pvalue), col = diffabundant, label = delabel)) + geom_point() + theme_minimal() + geom_text_repel(max.overlaps = Inf) + scale_color_manual(values = c(&quot;blue&quot;, &quot;black&quot;, &quot;gray&quot;, &quot;red&quot;)) + geom_vline(xintercept = c(-5, 5), col = &quot;darkred&quot;) + geom_hline(yintercept = -log10(0.05), col = &quot;darkred&quot;) "],["differential-abundance-analysis-at-gene-level.html", "Differential abundance analysis at gene level ToxA vs Control ToxB vs Control", " Differential abundance analysis at gene level ToxA vs Control # Create a list of genes with sgRNA indices to use in fry test index argument genesymbols &lt;- yy.norm$genes[, 1] genesymbollist &lt;- list() unq &lt;- unique(genesymbols) unq &lt;- unq[!is.na(unq)] for (i in unq) { sel &lt;- genesymbols == i &amp; !is.na(genesymbols) if (sum(sel) &gt; 3) genesymbollist[[i]] &lt;- which(sel) } fry.res &lt;- fry(yy.norm, index = genesymbollist, design, contrast = &quot;groupToxA&quot;) datatable(format(fry.res, format = &quot;e&quot;, digits = 3)) ToxB vs Control genesymbols &lt;- yy.norm$genes[, 1] genesymbollist &lt;- list() unq &lt;- unique(genesymbols) unq &lt;- unq[!is.na(unq)] for (i in unq) { sel &lt;- genesymbols == i &amp; !is.na(genesymbols) if (sum(sel) &gt; 3) genesymbollist[[i]] &lt;- which(sel) } fry.res &lt;- fry(yy.norm, index = genesymbollist, design, contrast = &quot;groupToxB&quot;) datatable(format(fry.res, format = &quot;e&quot;, digits = 3)) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
